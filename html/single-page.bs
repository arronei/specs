<h1>HTML</h1>

<pre class="metadata">
Shortname: html
Level: 5.1
Group: html
Status: WD
TR: http://www.w3.org/TR/html/
ED: https://github.com/w3c/html/
Previous Version: http://www.w3.org/TR/2014/WD-html51-20140204/

Editor: WHATWG
Editor: Simon Pieters, Opera Software, simonp@opera.com
Editor: Anne van Kesteren, Mozilla, annevk@annevk.nl
Editor: Philip JÃ¤genstedt, Opera Software, philipj@opera.com
Editor: Domenic Denicola, Google Inc., d@domenic.me
Editor: Ian Hickson, Google Inc., ian@hixie.ch
Editor: W3C
Editor: Steve Faulkner, The Paciello Group, sfaulkner@paciellogroup.com
Editor: Travis Leithead, Microsoft, travil@microsoft.com
Editor: Erika Doyle Navara, Microsoft, Erika.Doyle@microsoft.com
Editor: Edward O'Connor, Apple Inc., eoconnor@apple.com
Editor: Robin Berjon, W3C (Until August 2015), http://berjon.com/
Abstract: This specification defines the 5th major version, first minor revision of the core
          language of the World Wide Web: the Hypertext Markup Language (HTML). In this version,
          new features continue to be introduced to help Web application authors, new elements
          continue to be introduced based on research into prevailing authoring practices, and
          special attention continues to be given to defining clear conformance criteria for user
          agents in an effort to improve interoperability.
Ignored Vars: this, object, variable, optionalArgument, name
</pre>

<pre class="anchors">
urlPrefix: http://www.w3.org/TR/workers/; type: dfn; spec: WORKERS; text: worker;
urlPrefix: http://www.whatwg.org/specs/web-apps/current-work/; type: dfn; spec: WHATWG; text: WHATWG HTML specification;
urlPrefix: http://html5.org/r/8424/; type: dfn; text: 8424
</pre>

<h2 id="introduction">Introduction</h2>

<h3 id="background">Background</h3>

    <em>This section is non-normative.</em>

    The World Wide Web's markup language has always been HTML. HTML was primarily designed as a
    language for semantically describing scientific documents, although its general design and
    adaptations over the years have enabled it to be used to describe a number of other types of
    documents.

    The main area that has not been adequately addressed by HTML is a vague subject referred to as
    Web Applications. This standard attempts to rectify this, while at the same time updating the
    HTML language to address issues raised in the past few years.

<h3 id="audience">Audience</h3>

    <em>This section is non-normative.</em>

    This specification is intended for authors of documents and scripts that use the features
    defined in this specification<span class="impl">, implementors of tools that operate on pages
    that use the features defined in this specification, and individuals wishing to establish the
    correctness of documents or implementations with respect to the requirements of this
    specification</span>.

    This document is probably not suited to readers who do not already have at least a passing
    familiarity with Web technologies, as in places it sacrifices clarity for precision, and brevity
    for completeness. More approachable tutorials and authoring guides can provide a gentler
    introduction to the topic.

    In particular, familiarity with the basics of DOM is necessary for a complete understanding of
    some of the more technical parts of this specification. An understanding of Web IDL, HTTP, XML,
    Unicode, character encodings, JavaScript, and CSS will also be helpful in places but is not
    essential.

<h3 id="scope">Scope</h3>

    <em>This section is non-normative.</em>

    This specification is limited to providing a semantic-level markup language and associated
    semantic-level scripting APIs for authoring accessible pages on the Web ranging from static
    documents to dynamic applications.

    The scope of this specification does not include providing mechanisms for media-specific
    customization of presentation (although default rendering rules for Web browsers are included at
    the end of this specification, and several mechanisms for hooking into CSS are provided as part
    of the language).

    The scope of this specification is not to describe an entire operating system. In particular,
    hardware configuration software, image manipulation tools, and applications that users would be
    expected to use with high-end workstations on a daily basis are out of scope. In terms of
    applications, this specification is targeted specifically at applications that would be expected
    to be used by users on an occasional basis, or regularly but from disparate locations, with low
    CPU requirements. Examples of such applications include online purchasing systems, searching
    systems, games (especially multiplayer online games), public telephone books or address books,
    communications software (e-mail clients, instant messaging clients, discussion software),
    document editing software, etc.

<h3 id="history">History</h3>

    <em>This section is non-normative.</em>

    For its first five years (1990-1995), HTML went through a number of revisions and experienced a
    number of extensions, primarily hosted first at CERN, and then at the IETF.

    With the creation of the W3C, HTML's development changed venue again. A first abortive attempt
    at extending HTML in 1995 known as HTML 3.0 then made way to a more pragmatic approach known as
    HTML 3.2, which was completed in 1997. HTML4 quickly followed later that same year.

    The following year, the W3C membership decided to stop evolving HTML and instead begin work on
    an XML-based equivalent, called XHTML. This effort started with a reformulation of HTML4 in XML,
    known as XHTML 1.0, which added no new features except the new serialization, and which was
    completed in 2000. After XHTML 1.0, the W3C's focus turned to making it easier for other working
    groups to extend XHTML, under the banner of XHTML Modularization. In parallel with this, the W3C
    also worked on a new language that was not compatible with the earlier HTML and XHTML languages,
    calling it XHTML2.

    Around the time that HTML's evolution was stopped in 1998, parts of the API for HTML developed
    by browser vendors were specified and published under the name DOM Level 1 (in 1998) and DOM
    Level 2 Core and DOM Level 2 HTML (starting in 2000 and culminating in 2003). These efforts then
    petered out, with some DOM Level 3 specifications published in 2004 but the working group being
    closed before all the Level 3 drafts were completed.

    In 2003, the publication of XForms, a technology which was positioned as the next generation of
    Web forms, sparked a renewed interest in evolving HTML itself, rather than finding replacements
    for it. This interest was borne from the realization that XML's deployment as a Web technology
    was limited to entirely new technologies (like RSS and later Atom), rather than as a replacement
    for existing deployed technologies (like HTML).

    A proof of concept to show that it was possible to extend HTML4's forms to provide many of the
    features that XForms 1.0 introduced, without requiring browsers to implement rendering engines
    that were incompatible with existing HTML Web pages, was the first result of this renewed
    interest. At this early stage, while the draft was already publicly available, and input was
    already being solicited from all sources, the specification was only under Opera Software's
    copyright.

    The idea that HTML's evolution should be reopened was tested at a W3C workshop in 2004, where
    some of the principles that underlie the HTML5 work (described below), as well as the
    aforementioned early draft proposal covering just forms-related features, were presented to the
    W3C jointly by Mozilla and Opera. The proposal was rejected on the grounds that the proposal
    conflicted with the previously chosen direction for the Web's evolution; the W3C staff and
    membership voted to continue developing XML-based replacements instead.

    Shortly thereafter, Apple, Mozilla, and Opera jointly announced their intent to continue
    working on the effort under the umbrella of a new venue called the WHATWG. A public mailing list
    was created, and the draft was moved to the WHATWG site. The copyright was subsequently amended
    to be jointly owned by all three vendors, and to allow reuse of the specification.

    The WHATWG was based on several core principles, in particular that technologies need to be
    backwards compatible, that specifications and implementations need to match even if this means
    changing the specification rather than the implementations, and that specifications need to be
    detailed enough that implementations can achieve complete interoperability without
    reverse-engineering each other.

    The latter requirement in particular required that the scope of the HTML5 specification include
    what had previously been specified in three separate documents: HTML4, XHTML1, and DOM2 HTML. It
    also meant including significantly more detail than had previously been considered the norm.

    In 2006, the W3C indicated an interest to participate in the development of HTML5 after all,
    and in 2007 formed a working group chartered to work with the WHATWG on the development of the
    HTML5 specification. Apple, Mozilla, and Opera allowed the W3C to publish the specification
    under the W3C copyright, while keeping a version with the less restrictive license on the WHATWG
    site.

    For a number of years, both groups then worked together under the same editor: Ian Hickson.
    In 2011, the groups came to the conclusion that they had different goals: the W3C wanted to
    draw a line in the sand for features for a HTML5 Recommendation, while the WHATWG wanted to
    continue working on a Living Standard for HTML, continuously maintaining the specification
    and adding new features. In mid 2012, a new editing team was introduced at the W3C to take
    care of creating a HTML5 Recommendation and prepare a Working Draft for the next HTML
    version.

    Since then, the W3C HTML WG has been cherry picking patches from the WHATWG that resolved bugs
    registered on the W3C HTML specification or more accurately represented implemented reality in
    UAs. At time of publication of this document, patches from the <a>WHATWG HTML specification</a>
    have been merged until revision <a>8424</a> inclusive. The W3C HTML editors have also added
    patches that resulted from discussions and decisions made by the W3C HTML WG as well a bug
    fixes from bugs not shared by the WHATWG.

    A separate document is published to document the differences between the HTML specified
    in this document and the language described in the HTML4 specification. [[HTML5-DIFF]]

<h3 id="design-notes">Design notes</h3>

    <em>This section is non-normative.</em>

    It must be admitted that many aspects of HTML appear at first glance to be nonsensical and
    inconsistent.

    HTML, its supporting DOM APIs, as well as many of its supporting technologies, have been
    developed over a period of several decades by a wide array of people with different priorities
    who, in many cases, did not know of each other's existence.

    Features have thus arisen from many sources, and have not always been designed in especially
    consistent ways. Furthermore, because of the unique characteristics of the Web, implementation
    bugs have often become de-facto, and now de-jure, standards, as content is often unintentionally
    written in ways that rely on them before they can be fixed.

    Despite all this, efforts have been made to adhere to certain design goals. These are described
    in the next few subsections.

<h4 id="serializability-of-script-execution">Serializability of script execution</h4>

    <em>This section is non-normative.</em>

    To avoid exposing Web authors to the complexities of multithreading, the HTML and DOM APIs are
    designed such that no script can ever detect the simultaneous execution of other scripts. Even
    with <a>workers</a>, the intent is that the behavior of implementations
    can be thought of as completely serializing the execution of all scripts in all
    <span data-x="browsing context">browsing contexts</span>.

    The
    {{navigator}}.<<yieldForStorageUpdates()>>
    method, in this model, is equivalent to allowing other scripts to run while the calling script
    is blocked.

<h4 id="compliance-with-other-specifications">Compliance with other specifications</h4>

    <em>This section is non-normative.</em>

    This specification interacts with and relies on a wide variety of other specifications. In
    certain circumstances, unfortunately, conflicting needs have led to this specification violating
    the requirements of these other specifications. Whenever this has occurred, the transgressions
    have each been noted as a "<dfn>willful violation</dfn>", and the reason for the violation has
    been noted.

<h4 id="extensibility">Extensibility</h4>

    <em>This section is non-normative.</em>

    HTML has a wide array of extensibility mechanisms that can be used for adding semantics in a
    safe manner:

    * Authors can use the <code>class</code> attribute to extend elements,
        effectively creating their own elements, while using the most applicable existing "real"
        HTML element, so that browsers and other tools that don't know of the extension can still
        support it somewhat well. This is the tack used by microformats, for example.

    * Authors can include data for inline client-side scripts or server-side site-wide scripts
        to process using the <code>data-*=""</code> attributes. These are guaranteed
        to never be touched by browsers, and allow scripts to include data on HTML elements that
        scripts can then look for and process.

    * Authors can use the <code>&lt;meta name="" content=""></code> mechanism to
        include page-wide metadata by registering <span data-x="concept-meta-extensions">extensions
        to the predefined set of metadata names</span>.

    * Authors can use the <code>rel=""</code> mechanism to annotate
        links with specific meanings by registering <span data-x="concept-rel-extensions">extensions
        to the predefined set of link types</span>. This is also used by microformats. Additionally,
        absolute URLs that do not contain any non-ASCII characters, nor characters in the range
        U+0041 (LATIN CAPITAL LETTER A) through U+005A (LATIN CAPITAL LETTER Z) (inclusive), may be
        used as link types.

    * Authors can embed raw data using the <code>&lt;script type=""></code> mechanism with a custom
        type, for further handling by inline or server-side scripts.

    * Authors can create <span data-x="plugin">plugins</span> and invoke them using the
        <{embed}> element. This is how Flash works.

    * Authors can extend APIs using the JavaScript prototyping mechanism. This is widely used by
        script libraries, for instance.

<h3 id="html-vs-xhtml">HTML vs XHTML</h3>

    <em>This section is non-normative.</em>


    This specification defines an abstract language for describing documents and applications, and
    some APIs for interacting with in-memory representations of resources that use this language.


    The in-memory representation is known as "DOM HTML", or "the DOM" for short.

    There are various concrete syntaxes that can be used to transmit resources that use this
    abstract language, two of which are defined in this specification.

    The first such concrete syntax is the HTML syntax. This is the format suggested for most
    authors. It is compatible with most legacy Web browsers. If a document is transmitted with the
    <code>text/html</code> <span>MIME type</span>, then it will be processed as an HTML document by
    Web browsers. This specification defines version [LEVEL] of the HTML syntax, known as
    "HTML[LEVEL]".

    The second concrete syntax is the XHTML syntax, which is an application of XML. When a document
    is transmitted with an <span>XML MIME type</span>, such as <code>application/xhtml+xml</code>,
    then it is treated as an XML document by Web browsers, to be parsed by an XML processor. Authors
    are reminded that the processing for XML and HTML differs; in particular, even minor syntax
    errors will prevent a document labeled as XML from being rendered fully, whereas they would be
    ignored in the HTML syntax. This specification defines version [LEVEL] of the XHTML syntax,
    known as "XHTML[LEVEL]".

    The DOM, the HTML syntax, and the XHTML syntax cannot all represent the same content. For
    example, namespaces cannot be represented using the HTML syntax, but they are supported in the
    DOM and in the XHTML syntax. Similarly, documents that use the <code>noscript</code> feature can
    be represented using the HTML syntax, but cannot be represented with the DOM or in the XHTML
    syntax. Comments that contain the string "<code>--&gt;</code>" can only be represented in the
    DOM, not in the HTML and XHTML syntaxes.

<h3 id="structure-of-this-specification">Structure of this specification</h3>

    <em>This section is non-normative.</em>

    This specification is divided into the following major sections:

    <div dfn-for="spec">
        : [[#introduction]]
        :: Non-normative materials providing a context for the HTML standard.

        : [[#infrastructure]]
        :: The conformance classes, algorithms, definitions, and the common underpinnings of the
            rest of the specification.

        : [[#dom]]
        :: Documents are built from elements. These elements form a tree using the DOM. This section
            defines the features of this DOM, as well as introducing the features common to all
            elements, and the concepts used in defining elements.

        : [[#semantics]]
        :: Each element has a predefined meaning, which is explained in this section. Rules for
            authors on how to use the element<span class="impl">, along with user agent requirements
            for how to handle each element,</span> are also given. This includes large signature
            features of HTML such as video playback and subtitles, form controls and form
            submission, and a 2D graphics API known as the HTML canvas.

        : [[#editing]]
        :: HTML documents can provide a number of mechanisms for users to interact with and modify
            content, which are described in this section, such as how focus works, and
            drag-and-drop.

        : [[#browsers]]
        :: HTML documents do not exist in a vacuum &mdash; this section defines many of the features
            that affect environments that deal with multiple pages, such as Web browsers and offline
            caching of Web applications.

        : [[#webappapis]]
        :: This section introduces basic features for scripting of applications in HTML.

        : [[#syntax]]
        : [[#xhtml]]
        :: All of these features would be for naught if they couldn't be represented in a serialized
            form and sent to other people, and so these sections define the syntaxes of HTML and
            XHTML<span class="impl">, along with rules for how to parse content using those
            syntaxes</span>.

        : [[#rendering]]
        :: This section defines the default rendering rules for Web browsers.

        There are also some appendices, listing <a>obsolete features</a> and
        <a>IANA considerations</a>, and several indices.
    </div>

<h4 id="how-to-read-this-specification">How to read this specification</h4>

    This specification should be read like all other specifications. First, it should be read
      cover-to-cover, multiple times. Then, it should be read backwards at least once. Then it
      should be read by picking random sections from the contents list and following all the
      cross-references.

    As described in the conformance requirements section below, this specification describes
    conformance criteria for a variety of conformance classes. In particular, there are conformance
    requirements that apply to <em>producers</em>, for example authors and the documents they
    create, and there are conformance requirements that apply to <em>consumers</em>, for example Web
    browsers. They can be distinguished by what they are requiring: a requirement on a producer
    states what is allowed, while a requirement on a consumer states how software is to act.

    <div class="example">
        For example, "the <code>foo</code> attribute's value must be a <a>valid integer</a>" is a
        requirement on producers, as it lays out the allowed values; in contrast, the requirement "the
        <code>foo</code> attribute's value must be parsed using the <a>rules for parsing integers</a>"
        is a requirement on consumers, as it describes how to process the content.
    </div>

    <strong>Requirements on producers have no bearing whatsoever on consumers.</strong>

    <div class="example">
        Continuing the above example, a requirement stating that a particular attribute's value is
        constrained to being a <span>valid integer</span> emphatically does <em>not</em> imply
        anything about the requirements on consumers. It might be that the consumers are in fact
        required to treat the attribute as an opaque string, completely unaffected by whether the
        value conforms to the requirements or not. It might be (as in the previous example) that the
        consumers are required to parse the value using specific rules that define how invalid
        (non-numeric in this case) values are to be processed.
    </div>

<h4 id="typographic-conventions">Typographic conventions</h4>

    <div dfn-for="conventions">
        This is a definition, requirement, or explanation.

        <p class="note">This is a note.

        <p class="example">This is an example.

        <p class="&#x0058;&#x0058;&#x0058;">This is an open issue.

        <p class="warning">This is a warning.

        <pre class="idl noextract">interface <dfn>Example</dfn> {
            // this is an IDL definition
        };</pre>

        <dl class="domintro">
           : <var>variable</var> = <var>object</var> . <code data-x="x-that">method</code>( [ <var>optionalArgument</var> ] )
             ::
                This is a note to authors describing the usage of an interface.
            </dd>
        </dl>

        <pre class="css">/* this is a CSS fragment */</pre>

        The defining instance of a term is marked up like <dfn>this</dfn>. Uses of that
        term are marked up like <a>this</a> or like <i>this</i>.

        The defining instance of an element, attribute, or API is marked up like
        <dfn attribute><code>this</code></dfn>. References to that element, attribute, or API are marked
        up like <code>this</code>.

        Other code fragments are marked up <code>like this</code>.

        Variables are marked up like <var>this</var>.


        In an algorithm, steps in <a>synchronous sections</a> are marked with &#x231B;.

        In some cases, requirements are given in the form of lists with conditions and corresponding
        requirements. In such cases, the requirements that apply to a condition are always the first
        set of requirements that follow the condition, even in the case of there being multiple sets
        of conditions for those requirements. Such cases are presented as follows:

        <dl class="switch">
           : This is a condition
           : This is another condition
             :: This is the requirement that applies to the conditions above.</dd>

           : This is a third condition
             :: This is the requirement that applies to the third condition.</dd>
        </dl>
    </div>

<h3 id="fingerprint">Privacy concerns</h3>

    <em>This section is non-normative.</em>

    Some features of HTML trade user convenience for a measure of user privacy.

    In general, due to the Internet's architecture, a user can be distinguished from another by the
    user's IP address. IP addresses do not perfectly match to a user; as a user moves from device to
    device, or from network to network, their IP address will change; similarly, NAT routing, proxy
    servers, and shared computers enable packets that appear to all come from a single IP address to
    actually map to multiple users. Technologies such as onion routing can be used to further
    anonymize requests so that requests from a single user at one node on the Internet appear to come
    from many disparate parts of the network.

    However, the IP address used for a user's requests is not the only mechanism by which a user's
    requests could be related to each other. Cookies, for example, are designed specifically to enable
    this, and are the basis of most of the Web's session features that enable you to log into a site
    with which you have an account.

    There are other mechanisms that are more subtle. Certain characteristics of a user's system can
    be used to distinguish groups of users from each other; by collecting enough such information, an
    individual user's browser's "digital fingerprint" can be computed, which can be as good, if not
    better, as an IP address in ascertaining which requests are from the same user.

    Grouping requests in this manner, especially across multiple sites, can be used for both benign
    (and even arguably positive) purposes, as well as for malevolent purposes. An example of a
    reasonably benign purpose would be determining whether a particular person seems to prefer sites
    with dog illustrations as opposed to sites with cat illustrations (based on how often they visit
    the sites in question) and then automatically using the preferred illustrations on subsequent
    visits to participating sites. Malevolent purposes, however, could include governments combining
    information such as the person's home address (determined from the addresses they use when getting
    driving directions on one site) with their apparent political affiliations (determined by
    examining the forum sites that they participate in) to determine whether the person should be
    prevented from voting in an election.

    Since the malevolent purposes can be remarkably evil, user agent implementors are encouraged to
    consider how to provide their users with tools to minimize leaking information that could be used
    to fingerprint a user.

    Unfortunately, as the first paragraph in this section implies, sometimes there is great benefit
    to be derived from exposing the very information that can also be used for fingerprinting
    purposes, so it's not as easy as simply blocking all possible leaks. For instance, the ability to
    log into a site to post under a specific identity requires that the user's requests be
    identifiable as all being from the same user, more or less by definition. More subtly, though,
    information such as how wide text is, which is necessary for many effects that involve drawing
    text onto a canvas (e.g. any effect that involves drawing a border around the text) also leaks
    information that can be used to group a user's requests. (In this case, by potentially exposing,
    via a brute force search, which fonts a user has installed, information which can vary
    considerably from user to user.)

    Features in this specification which can be <dfn id="fingerprinting-vector">used to
    fingerprint the user</dfn> are marked as this paragraph is.
    <span class="fingerprint"><a href="#fingerprinting-vector"><img height="21" src="images/fingerprint.png" width="15" alt="(This is a fingerprinting vector.)" /></a></span>

    Other features in the platform can be used for the same purpose, though, including, though not
    limited to:


    * The exact list of which features a user agents supports.

    * The maximum allowed stack depth for recursion in script.

    * Features that describe the user's environment, like Media Queries and the <code>Screen</code>
        object. [[!MEDIAQ]] [[!CSSOM-VIEW]]

    * The user's time zone.

<h3 id="a-quick-introduction-to-html">A quick introduction to HTML</h3>

    <em>This section is non-normative.</em>

    A basic HTML document looks like this:

    <pre id="intro-early-example" highlight="html">&lt;!DOCTYPE html>
    &lt;html>
     &lt;head>
      &lt;title>Sample page&lt;/title>
     &lt;/head>
     &lt;body>
      &lt;h1>Sample page&lt;/h1>
      &lt;p>This is a &lt;a href="demo.html">simple&lt;/a> sample.&lt;/p>
      &lt;!-- this is a comment -->
     &lt;/body>
    &lt;/html></pre>

    HTML documents consist of a tree of elements and text. Each element is denoted in the source by
    a <a>start tag</a>, such as "<code>&lt;body></code>", and an <a>end tag</a>, such as
    "<code>&lt;/body></code>". (Certain start tags and end tags can in certain cases be
    <a>omitted</a> and are implied by other tags.)

    Tags have to be nested such that elements are all completely within each other, without
    overlapping:

    <pre class="bad" highlight="html">&lt;p>This is &lt;em>very &lt;strong>wrong&lt;/em>!&lt;/strong>&lt;/p></pre>
    <pre highlight="html">&lt;p>This &lt;em>is &lt;strong>correct&lt;/strong>.&lt;/em>&lt;/p></pre>

    This specification defines a set of elements that can be used in HTML, along with rules about
    the ways in which the elements can be nested.

    Elements can have attributes, which control how the elements work. In the example below, there
    is a <a>hyperlink</a>, formed using the <code>a</code> element and its <code>href</code>
    attribute:

    <pre highlight="html">&lt;a href="demo.html">simple&lt;/a></pre>

    <a>Attributes</a> are placed inside the start tag, and consist of a <a>name</a> and a
    <a>value</a>, separated by an "<code>=</code>" character. The attribute value can remain
    <a>unquoted</a> if it doesn't contain <a>space characters</a> or any of <code>"</code>
    <code>'</code> <code>`</code> <code>=</code> <code>&lt;</code> or <code>&gt;</code>. Otherwise,
    it has to be quoted using either single or double quotes. The value, along with the
    "<code>=</code>" character, can be omitted altogether if the value is the empty string.
<pre class="link-defaults">
spec:dom-ls; type:dfn; for:Attr; text:name
</pre>
    <pre highlight="html">&lt;!-- empty attributes -->
    &lt;input name=address disabled>
    &lt;input name=address disabled="">

    &lt;!-- attributes with a value -->
    &lt;input name=address maxlength=200>
    &lt;input name=address maxlength='200'>
    &lt;input name=address maxlength="200"></pre>

    HTML user agents (e.g. Web browsers) then <i>parse</i> this markup, turning it into a DOM
    (Document Object Model) tree. A DOM tree is an in-memory representation of a document.

    DOM trees contain several kinds of nodes, in particular a <code>DocumentType</code> node,
    <code>Element</code> nodes, <code>Text</code> nodes, <code>Comment</code> nodes, and in some
    cases <code>ProcessingInstruction</code> nodes.

    The <a>markup snippet at the top of this section</a> would be turned
    into the following DOM tree:

    <ul class="domTree">
        <li class="t10">DOCTYPE: <code>html</code></li>
        <li class="t1"><code>html</code>
            <ul>
                <li class="t1"><code>head</code>
                    <ul>
                        <li class="t3"><code>#text</code>: <span>&#x23CE;&#x2423;&#x2423;</span></li>
                        <li class="t1"><code>title</code>
                            <ul>
                                <li class="t3"><code>#text</code>: <span>Sample page</span></li>
                            </ul>
                        </li>
                        <li class="t3"><code>#text</code>: <span>&#x23CE;&#x2423;</span></li>
                    </ul>
                </li>
                <li class="t3"><code>#text</code>: <span>&#x23CE;&#x2423;</span></li>
                <li class="t1"><code>body</code>
                    <ul>
                        <li class="t3"><code>#text</code>: <span>&#x23CE;&#x2423;&#x2423;</span></li>
                        <li class="t1"><code>h1</code>
                            <ul>
                                <li class="t3"><code>#text</code>: <span>Sample page</span></li>
                            </ul>
                        </li>
                        <li class="t3"><code>#text</code>: <span>&#x23CE;&#x2423;&#x2423;</span></li>
                        <li class="t1"><code>p</code>
                            <ul>
                                <li class="t3"><code>#text</code>: <span>This is a</span></li>
                                <li class="t1"><code>a</code> <span class="t2"><code class="attribute name" data-x="attr-hyperlink-href">href</code>="<code class="attribute value">demo.html</code>"</span>
                                    <ul>
                                        <li class="t3"><code>#text</code>: <span>simple</span></li>
                                    </ul>
                                </li>
                                <li class="t3"><code>#text</code>: <span> sample.</span></li>
                            </ul>
                        </li>
                        <li class="t3"><code>#text</code>: <span>&#x23CE;&#x2423;&#x2423;</span></li>
                        <li class="t8"><code>#comment</code>: <span> this is a comment </span></li>
                        <li class="t3"><code>#text</code>: <span>&#x23CE;&#x2423;&#x23CE;</span></li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    The <span>root element</span> of this tree is the <code>html</code> element, which is the
    element always found at the root of HTML documents. It contains two elements, <code>head</code>
    and <code>body</code>, as well as a <code>Text</code> node between them.

    There are many more <code>Text</code> nodes in the DOM tree than one would initially expect,
    because the source contains a number of spaces (represented here by "&#x2423;") and line breaks
    ("&#x23CE;") that all end up as <code>Text</code> nodes in the DOM. However, for historical
    reasons not all of the spaces and line breaks in the original markup appear in the DOM. In
    particular, all the whitespace before <code>head</code> start tag ends up being dropped
    silently, and all the whitespace after the <code>body</code> end tag ends up placed at the end
    of the <code>body</code>.

    The <code>head</code> element contains a <code>title</code> element, which itself contains a
    <code>Text</code> node with the text "Sample page". Similarly, the <code>body</code> element
    contains an <code>h1</code> element, a <code>p</code> element, and a comment.

    <hr />

    This DOM tree can be manipulated from scripts in the page. Scripts (typically in JavaScript)
    are small programs that can be embedded using the <code>script</code> element or using
    <span>event handler content attributes</span>. For example, here is a form with a script that
    sets the value of the form's <code>output</code> element to say "Hello World"

    <pre highlight="html">&lt;form name="main">
     Result: &lt;output name="result">&lt;/output>
     &lt;script>
      document.forms.main.elements.result.value = 'Hello World';
     &lt;/script>
    &lt;/form></pre>

    Each element in the DOM tree is represented by an object, and these objects have APIs so that
    they can be manipulated. For instance, a link (e.g. the <code>a</code> element in the tree
    above) can have its "<code data-x="attr-hyperlink-href">href</code>" attribute changed in
    several ways:

    <pre highlight="javascript">var a = document.links[0]; // obtain the first link in the document
    a.href = 'sample.html'; // change the destination URL of the link
    a.protocol = 'https'; // change just the scheme part of the URL
    a.setAttribute('href', 'http://example.com/'); // change the content attribute directly</pre>

    Since DOM trees are used as the way to represent HTML documents when they are processed and
    presented by implementations (especially interactive implementations like Web browsers), this
    specification is mostly phrased in terms of DOM trees, instead of the markup described above.

    <hr />

    HTML documents represent a media-independent description of interactive content. HTML documents
    might be rendered to a screen, or through a speech synthesizer, or on a braille display. To
    influence exactly how such rendering takes place, authors can use a styling language such as
    CSS.

    In the following example, the page has been made yellow-on-blue using CSS.

    <pre highlight=html>&lt;!DOCTYPE html>
    &lt;html>
     &lt;head>
      &lt;title>Sample styled page&lt;/title>
      &lt;style>
       body { background: navy; color: yellow; }
      &lt;/style>
     &lt;/head>
     &lt;body>
      &lt;h1>Sample styled page&lt;/h1>
      &lt;p>This page is just a demo.&lt;/p>
     &lt;/body>
    &lt;/html></pre>

    For more details on how to use HTML, authors are encouraged to consult tutorials and guides.
    Some of the examples included in this specification might also be of use, but the novice author
    is cautioned that this specification, by necessity, defines the language with a level of detail
    that might be difficult to understand at first.

<h4 id="writing-secure-applications-with-html">Writing secure applications with HTML</h4>

    <em>This section is non-normative.</em>

    When HTML is used to create interactive sites, care needs to be taken to avoid introducing
    vulnerabilities through which attackers can compromise the integrity of the site itself or of
    the site's users.

    A comprehensive study of this matter is beyond the scope of this document, and authors are
    strongly encouraged to study the matter in more detail. However, this section attempts to
    provide a quick introduction to some common pitfalls in HTML application development.

    The security model of the Web is based on the concept of "origins", and correspondingly many of
    the potential attacks on the Web involve cross-origin actions. [[!ORIGIN]]

    <dl>
       : Not validating user input
       : Cross-site scripting (XSS)
       : SQL injection
         ::
        When accepting untrusted input, e.g. user-generated content such as text comments, values in
        URL parameters, messages from third-party sites, etc, it is imperative that the data be
        validated before use, and properly escaped when displayed. Failing to do this can allow a
        hostile user to perform a variety of attacks, ranging from the potentially benign, such as
        providing bogus user information like a negative age, to the serious, such as running scripts
        every time a user looks at a page that includes the information, potentially propagating the
        attack in the process, to the catastrophic, such as deleting all data in the server.

        When writing filters to validate user input, it is imperative that filters always be
        safelist-based, allowing known-safe constructs and disallowing all other input. Blocklist-based
        filters that disallow known-bad inputs and allow everything else are not secure, as not
        everything that is bad is yet known (for example, because it might be invented in the
        future).

        <div class="example">
            For example, suppose a page looked at its URL's query string to determine what to display,
            and the site then redirected the user to that page to display a message, as in:

            <pre highlight="html">&lt;ul>
             &lt;li>&lt;a href="message.cgi?say=Hello">Say Hello&lt;/a>
             &lt;li>&lt;a href="message.cgi?say=Welcome">Say Welcome&lt;/a>
             &lt;li>&lt;a href="message.cgi?say=Kittens">Say Kittens&lt;/a>
            &lt;/ul></pre>

            If the message was just displayed to the user without escaping, a hostile attacker could
            then craft a URL that contained a script element:

            <pre>http://example.com/message.cgi?say=%3Cscript%3Ealert%28%27Oh%20no%21%27%29%3C/script%3E</pre>

            If the attacker then convinced a victim user to visit this page, a script of the
            attacker's choosing would run on the page. Such a script could do any number of hostile
            actions, limited only by what the site offers: if the site is an e-commerce shop, for
            instance, such a script could cause the user to unknowingly make arbitrarily many
            unwanted purchases.

            This is called a cross-site scripting attack.
        </div>

        There are many constructs that can be used to try to trick a site into executing code. Here
        are some that authors are encouraged to consider when writing safelist filters:

        * When allowing harmless-seeming elements like <code>img</code>, it is important to safelist
            any provided attributes as well. If one allowed all attributes then an attacker could,
            for instance, use the <code data-x="handler-onload">onload</code> attribute to run
            arbitrary script.

        * When allowing URLs to be provided (e.g. for links), the scheme of each URL also needs to
            be explicitly safelisted, as there are many schemes that can be abused. The most
            prominent example is "<code data-x="javascript protocol">javascript:</code>", but user
            agents can implement (and indeed, have historically implemented) others.

        * Allowing a <code>base</code> element to be inserted means any <code>script</code> elements
            in the page with relative links can be hijacked, and similarly that any form submissions
            can get redirected to a hostile site.
       </dd>

       : Cross-site request forgery (CSRF)
         ::
            If a site allows a user to make form submissions with user-specific side-effects, for
            example posting messages on a forum under the user's name, making purchases, or applying
            for a passport, it is important to verify that the request was made by the user
            intentionally, rather than by another site tricking the user into making the request
            unknowingly.

            This problem exists because HTML forms can be submitted to other origins.

            Sites can prevent such attacks by populating forms with user-specific hidden tokens, or
            by checking <code data-x="http-origin">Origin</code> headers on all requests.
       </dd>

       : Clickjacking
         ::
            A page that provides users with an interface to perform actions that the user might not
            wish to perform needs to be designed so as to avoid the possibility that users can be
            tricked into activating the interface.

            One way that a user could be so tricked is if a hostile site places the victim site in a
            small <code>iframe</code> and then convinces the user to click, for instance by having
            the user play a reaction game. Once the user is playing the game, the hostile site can
            quickly position the iframe under the mouse cursor just as the user is about to click,
            thus tricking the user into clicking the victim site's interface.

            To avoid this, sites that do not expect to be used in frames are encouraged to only
            enable their interface if they detect that they are not in a frame (e.g. by comparing
            the <code>window</code> object to the value of the <code>top</code> attribute).
        </dd>
    </dl>


<hr />
<hr />
<hr />
<h2 id="infrastructure">Common infrastructure</h2>

<h3 id="terminology">Terminology</h3>

  This specification refers to both HTML and XML attributes and IDL attributes, often in the same
  context. When it is not clear which is being referred to, they are referred to as
  <dfn>content attributes</dfn> for HTML and XML attributes, and <dfn>IDL attributes</dfn> for those
  defined on IDL interfaces. Similarly, the term "properties" is used for
  both JavaScript object properties and CSS properties. When these are ambiguous they are qualified
  as <dfn>object properties</dfn> and <dfn>CSS properties</dfn> respectively.

  Generally, when the specification states that a feature applies to <a>the HTML syntax</a>
  or <a>the XHTML syntax</a>, it also includes the other. When a feature specifically only
  applies to one of the two languages, it is called out by explicitly stating that it does not apply
  to the other format, as in "for HTML, ... (this does not apply to XHTML)".

  This specification uses the term <dfn>document</dfn> to refer to any use of HTML,
  ranging from short static documents to long essays or reports with rich multimedia, as well as to
  fully-fledged interactive applications. The term is used to refer both to <code>Document</code>
  objects and their descendant DOM trees, and to serialized byte streams using the
  <a>HTML syntax</a> or <a>XHTML syntax</a>, depending on context.

  In the context of the DOM structures, the terms <a>HTML document</a> and <a>XML document</a> are
  used as defined in the DOM specification, and refer specifically to two different modes that
  <code>Document</code> objects can find themselves in. [[!DOM]] (Such uses are always hyperlinked
  to their definition.)

  In the context of byte streams, the term HTML document refers to resources labeled as
  <code>text/html</code>, and the term XML document refers to resources labeled with an <a>XML
  MIME type</a>.

  The term <dfn>XHTML document</dfn> is used to refer to both <code>Document</code>s in the
  <a>XML document</a> mode that contains element nodes in the <a>HTML namespace</a>, and byte
  streams labeled with an <span>XML MIME type</span> that contain elements from the
  <a>HTML namespace</a>, depending on context.

<hr />

  For simplicity, terms such as <dfn>shown</dfn>, <dfn>displayed</dfn>, and
  <dfn>visible</dfn> might sometimes be used when referring to the way a document is
  rendered to the user. These terms are not meant to imply a visual medium; they must be considered
  to apply to other media in equivalent ways.

  <div class="impl">

  When an algorithm B says to return to another algorithm A, it implies that A called B. Upon
  returning to A, the implementation must continue from where it left off in calling B. Some
  algorithms run <dfn>in parallel</dfn>; this means that the algorithm's subsequent steps are to be
  run, one after another, at the same time as other logic in the specification (e.g. at the same
  time as the <a>event loop</a>). This specification does not define the precise mechanism by
  which this is achieved, be it time-sharing cooperative multitasking, fibers, threads, processes,
  using different hyperthreads, cores, CPUs, machines, etc. By contrast, an operation that is to run
  <dfn>immediately</dfn> must interrupt the currently running task, run itself, and then resume the
  previously running task.

  </div>

  <!-- should find somewhere more appropriate to put this -->
  The term "transparent black" refers to the color with red, green, blue, and alpha channels all
  set to zero.

<h4 id="resources">Resources</h4>

  The specification uses the term <dfn>supported</dfn> when referring to whether a user
  agent has an implementation capable of decoding the semantics of an external resource. A format or
  type is said to be <i>supported</i> if the implementation can process an external resource of that
  format or type without critical aspects of the resource being ignored. Whether a specific resource
  is <i>supported</i> can depend on what features of the resource's format are in use.

  <p class="example">
    For example, a PNG image would be considered to be in a supported format if its
    pixel data could be decoded and rendered, even if, unbeknownst to the implementation, the image
    also contained animation data.
  </p>

  <p class="example">
    An MPEG-4 video file would not be considered to be in a supported format if the
    compression format used was not supported, even if the implementation could determine the
    dimensions of the movie from the file's metadata.
  </p>

  What some specifications, in particular the HTTP specification, refer to as a
  <i>representation</i> is referred to in this specification as a <dfn>resource</dfn>. [[!HTTP]]

  The term <dfn>MIME type</dfn> is used to refer to what is sometimes called an <i>Internet media
  type</i> in protocol literature. The term <i>media type</i> in this specification is used to refer
  to the type of media intended for presentation, as used by the CSS specifications. [[!RFC2046]]
  [[MQ]]

  A string is a <dfn>valid MIME type</dfn> if it matches the <code>media-type</code>
  rule defined in section 3.7 "Media Types" of RFC 2616. In particular, a <span>valid MIME
  type</span> may include MIME type parameters. [[HTTP]]

  A string is a <dfn>valid MIME type with no parameters</dfn> if it matches the
  <code>media-type</code> rule defined in section 3.7 "Media Types" of RFC 2616, but does not
  contain any U+003B SEMICOLON characters (;). In other words, if it consists only of a type and
  subtype, with no MIME Type parameters. [[HTTP]]

  The term <dfn>HTML MIME type</dfn> is used to refer to the <a>MIME type</a>
  <code>text/html</code>.

  A resource's <dfn>critical subresources</dfn> are those that the resource needs to have
  available to be correctly processed. Which resources are considered critical or not is defined by
  the specification that defines the resource's format.

  The term <dfn><code>data:</code> URL</dfn> refers to <a>URLs</a> that use the <code>data:</code>
  scheme. [[!RFC2397]]

  <h4 id="xml">XML</h4>

  To ease migration from HTML to XHTML, UAs conforming to this specification will place elements in
  HTML in the <code>http://www.w3.org/1999/xhtml</code> namespace, at least for the purposes of the
  DOM and CSS. The term "<dfn>HTML elements</dfn>", when used in this specification, refers to any
  element in that namespace, and thus refers to both HTML and XHTML elements.

  Except where otherwise stated, all elements defined or mentioned in this specification are in
  the <span>HTML namespace</span> ("<code>http://www.w3.org/1999/xhtml</code>"), and all
  attributes defined or mentioned in this specification have no namespace.

  The term <dfn>element type</dfn> is used to refer to the set of elements that have a given
  local name and namespace. For example, <code>button</code> elements are elements with the element
  type <code>button</code>, meaning they have the local name "<code>button</code>" and
  (implicitly as defined above) the <a>HTML namespace</a>.

  Attribute names are said to be <dfn>XML-compatible</dfn> if they match the <a
  href="http://www.w3.org/TR/xml/#NT-Name"><code>Name</code></a> production defined in XML
  and they contain no U+003A COLON characters (:). [[!XML]]

  The term <dfn>XML MIME type</dfn> is used to refer to the <a>MIME types</a> <code>text/xml</code>,
  <code>application/xml</code>, and any <a>MIME type</a> whose subtype ends with the four characters
  "<code>+xml</code>".
  [[!RFC7303]]


  <h4 id="dom-trees">DOM trees</h4>

  The <dfn>root element of a <code>Document</code> object</dfn> is that <code>Document</code>'s
  first element child, if any. If it does not have one then the <code>Document</code> has no root
  element.

  The term <dfn>root element</dfn>, when not referring to a <code>Document</code> object's root
  element, means the furthest ancestor element node of whatever node is being discussed, or the node
  itself if it has no ancestors. When the node is a part of the document, then the node's <a>root
  element</a> is indeed the document's root element; however, if the node is not currently part
  of the document tree, the root element will be an orphaned node.

  When an element's <a>root element</a> is the <a>root element of a
  <code>Document</code> object</a>, it is said to be <dfn>in a <code>Document</code></dfn>. An
  element is said to have been <dfn>inserted into a document</dfn> when its <a>root element</a>
  changes and is now the document's <a>root element</a>. Analogously, an element is said to have
  been <dfn data-x="remove an element from a document">removed from a document</dfn> when its
  <a>root element</a> changes from being the document's <a>root element</a> to being another
  element.

  A node's <dfn>home subtree</dfn> is the subtree rooted at that node's <a>root element</a>.
  When a node is <a>in a <code>Document</code></a>, its <a>home subtree</a> is that
  <code>Document</code>'s tree.

  The <code>Document</code> of a <code>Node</code> (such as an element) is the
  <code>Document</code> that the <code>Node</code>'s <code>ownerDocument</code> IDL attribute
  returns. When a <code>Node</code> is <a>in a <code>Document</code></a> then that
  <code>Document</code> is always the <code>Node</code>'s <code>Document</code>, and the
  <code>Node</code>'s <code>ownerDocument</code> IDL attribute thus always returns that
  <code>Document</code>.

  The <code>Document</code> of a content attribute is the <code>Document</code> of the
  attribute's element.

  The term <dfn>tree order</dfn> means a pre-order, depth-first traversal of DOM nodes involved
  (through the <code data-x="dom-Node-parentNode">parentNode</code>/<code
  data-x="dom-Node-childNodes">childNodes</code> relationship).

  When it is stated that some element or attribute is <dfn data-x="ignore">ignored</dfn>, or
  treated as some other value, or handled as if it was something else, this refers only to the
  processing of the node after it is in the DOM. <span class="impl">A user agent must not mutate the
  DOM in such situations.</span>

  A content attribute is said to <dfn>change</dfn> value only if its new value is
  different than its previous value; setting an attribute to a value it already has does not change
  it.

  The term <dfn>empty</dfn>, when used of an attribute value, <code>Text</code> node, or
  string, means that the length of the text is zero (i.e. not even containing spaces or <a>control
  characters</a>).

  A <dfn>node <var>A</var> is inserted</dfn> into a node <var>B</var>
  when the <a>insertion steps</a> are invoked with
  <var>A</var> as the argument and <var>A</var>'s new parent is <var>B</var>. Similarly, a <dfn
  data-x="nodes are removed">node <var>A</var> is removed</dfn> from a node <var>B</var> when the
  <a>removing steps</a> are invoked with <var>A</var> as the <var>removedNode</var> argument and
  <var>B</var> as the <var>oldParent</var> argument.

  <h4 id="scripting">Scripting</h4>

  The construction "a <code>Foo</code> object", where <code>Foo</code> is actually an interface,
  is sometimes used instead of the more accurate "an object implementing the interface
  <code>Foo</code>".

  An IDL attribute is said to be <dfn>getting</dfn> when its value is being retrieved
  (e.g. by author script), and is said to be <dfn>setting</dfn> when a new value is
  assigned to it.

  If a DOM object is said to be <dfn>live</dfn>, then the attributes and methods on that object
  <span class="impl">must</span> operate on the actual underlying data, not a snapshot of the
  data.

  In the contexts of events, the terms <i>fire</i> and <i>dispatch</i> are used as defined in the
  DOM specification: <dfn data-x="concept-event-fire">firing</dfn> an event means to create and
  <a>dispatch</a> it, and <dfn>dispatching</dfn> an event means to follow the steps that propagate
  the event through the tree. The term <dfn>trusted event</dfn> is used to refer to events whose
  <code>isTrusted</code> attribute is initialized to true. [[!DOM]]


  <h4 id="plugins">Plugins</h4>

  The term <dfn>plugin</dfn> refers to a user-agent defined set of content handlers used by the
  user agent that can take part in the user agent's rendering of a <code>Document</code> object, but
  that neither act as <a>child browsing contexts</a> of the <code>Document</code> nor introduce any
  <code>Node</code> objects to the <code>Document</code>'s DOM.

  Typically such content handlers are provided by third parties, though a user agent can also
  designate built-in content handlers as plugins.

  <div class="impl">

  A user agent must not consider the types <code>text/plain</code> and
  <code>application/octet-stream</code> as having a registered <a>plugin</a>.

  </div>

  <p class="example">
    One example of a plugin would be a PDF viewer that is instantiated in a
    <a>browsing context</a> when the user navigates to a PDF file. This would count as a plugin
    regardless of whether the party that implemented the PDF viewer component was the same as that
    which implemented the user agent itself. However, a PDF viewer application that launches separate
    from the user agent (as opposed to using the same interface) is not a plugin by this
    definition.
  </p>

  <p class="note">
    This specification does not define a mechanism for interacting with plugins, as it
    is expected to be user-agent- and platform-specific. Some UAs might opt to support a plugin
    mechanism such as the Netscape Plugin API; others might use remote content converters or have
    built-in support for certain types. Indeed, this specification doesn't require user agents to
    support plugins at all. [[!NPAPI]]
  </p>

  A plugin can be <dfn data-x="concept-plugin-secure">secured</dfn> if it honors the semantics of
  the <code data-x="attr-iframe-sandbox">sandbox</code> attribute.

  <p class="example">
    For example, a secured plugin would prevent its contents from creating pop-up windows when the
    plugin is instantiated inside a sandboxed <code>iframe</code>.
  </p>

  <div class="impl">

  <p class="warning">
    Browsers should take extreme care when interacting with external content intended for
    <span data-x="plugin">plugins</span>. When third-party software is run with the same
    privileges as the user agent itself, vulnerabilities in the third-party software become as
    dangerous as those in the user agent.
  </p>

  Since different users having differents sets of <a>plugins</a> provides a
  fingerprinting vector that increases the chances of users being uniquely identified, user agents
  are encouraged to support the exact same set of <a>plugins</a> for each
  user.

  <a class="fingerprint" href="#fingerprinting-vector"><img height="21" src="images/fingerprint.png" width="15" alt="(This is a fingerprinting vector.)" /></a>

  </div>

<h4 id="encoding-terminology">Character encodings</h4>

  A <dfn>character encoding</dfn>, or just <i>encoding</i> where that is not
  ambiguous, is a defined way to convert between byte streams and Unicode strings, as defined in the
  Encoding standard. An <a>encoding</a> has an <dfn>encoding name</dfn> and one or more
  <dfn>encoding labels</dfn>, referred to as the encoding's <i>name</i> and <i>labels</i> in the
  Encoding standard. [[!ENCODING]]

  An <dfn>ASCII-compatible character encoding</dfn> is a single-byte or variable-length
  <a>encoding</a> in which the bytes 0x09, 0x0A, 0x0C, 0x0D, 0x20 - 0x22, 0x26, 0x27, 0x2C -
  0x3F, 0x41 - 0x5A, and 0x61 - 0x7A, ignoring bytes that are the second and later bytes of multibyte
  sequences, all correspond to single-byte sequences that map to the same Unicode characters as
  those bytes in Windows-1252. [[!ENCODING]]

  <p class="note">
    This includes such encodings as Shift_JIS, HZ-GB-2312, and variants of ISO-2022,
    even though it is possible in these encodings for bytes like 0x70 to be part of longer sequences
    that are unrelated to their interpretation as ASCII. It excludes UTF-16 variants, as well as
    obsolete legacy encodings such as UTF-7, GSM03.38, and EBCDIC variants.
  </p>

  The term <dfn>a UTF-16 encoding</dfn> refers to any variant of UTF-16: UTF-16LE or UTF-16BE,
  regardless of the presence or absence of a BOM. [[!ENCODING]]

  The term <dfn>code unit</dfn> is used as defined in the Web IDL specification: a 16 bit
  unsigned integer, the smallest atomic component of a <code>DOMString</code>. (This is a narrower
  definition than the one used in Unicode, and is not the same as a <i>code point</i>.) [[WEBIDL]]

  The term <dfn>Unicode code point</dfn> means a <i>Unicode scalar value</i> where
  possible, and an isolated surrogate code point when not. When a conformance requirement is defined
  in terms of characters or Unicode code points, a pair of <a>code units</a> consisting of a high
  surrogate followed by a low surrogate must be treated as the single code point represented by the
  surrogate pair, but isolated surrogates must each be treated as the single code point with the
  value of the surrogate. [[!UNICODE]]

  In this specification, the term <dfn>character</dfn>, when not qualified as <em>Unicode</em>
  character, is synonymous with the term <a>Unicode code point</a>.

  The term <dfn>Unicode character</dfn> is used to mean a <i>Unicode scalar value</i>
  (i.e. any Unicode code point that is not a surrogate code point). [[!UNICODE]]

  The <dfn>code-unit length</dfn> of a string is the number of <a>code
  units</a> in that string.

  <p class="note">
    This complexity results from the historical decision to define the DOM API in
    terms of 16 bit (UTF-16) <a>code units</a>, rather than in terms of <a>Unicode characters</a>.
  </p>


<h3 id="conformance-requirements">Conformance requirements</h3>

  All diagrams, examples, and notes in this specification are non-normative, as are all sections
  explicitly marked non-normative. Everything else in this specification is normative.

  The key words "MUST", "MUST NOT", "SHOULD", "SHOULD NOT", "MAY", and "OPTIONAL" in the normative
  parts of this document are to be interpreted as described in RFC2119. The key word "OPTIONALLY" in
  the normative parts of this document is to be interpreted with the same normative meaning as "MAY"
  and "OPTIONAL". For readability, these words do not appear in all uppercase letters in this
  specification. [[RFC2119]]

  <div class="impl">

  Requirements phrased in the imperative as part of algorithms (such as "strip any leading space
  characters" or "return false and abort these steps") are to be interpreted with the meaning of the
  key word ("must", "should", "may", etc) used in introducing the algorithm.

  <div class="example">

   For example, were the spec to say:

   <pre>To eat an orange, the user must:
1. Peel the orange.
2. Separate each slice of the orange.
3. Eat the orange slices.</pre>

   ...it would be equivalent to the following:

   <pre>To eat an orange:
1. The user must peel the orange.
2. The user must separate each slice of the orange.
3. The user must eat the orange slices.</pre>

   Here the key word is "must".

   The former (imperative) style is generally preferred in this specification for stylistic
   reasons.

  </div>

  Conformance requirements phrased as algorithms or specific steps may be implemented in any
  manner, so long as the end result is equivalent. (In particular, the algorithms defined in this
  specification are intended to be easy to follow, and not intended to be performant.)

  </div>


  <div class="impl">

<h4 id="conformance-classes">Conformance classes</h4>

  This specification describes the conformance criteria for <span class="impl">user agents
  (relevant to implementors) and</span> documents<span class="impl"> (relevant to authors and
  authoring tool implementors)</span>.

  <dfn>Conforming documents</dfn> are those that comply with all the conformance criteria for
  documents. For readability, some of these conformance requirements are phrased as conformance
  requirements on authors; such requirements are implicitly requirements on documents: by
  definition, all documents are assumed to have had an author. (In some cases, that author may
  itself be a user agent &mdash; such user agents are subject to additional rules, as explained
  below.)

  <p class="example">
    For example, if a requirement states that "authors must not use the
    <code>foobar</code> element", it would imply that documents are not allowed to contain elements
    named <code>foobar</code>.
  </p>

  <p class="note impl">
    There is no implied relationship between document conformance requirements
    and implementation conformance requirements. User agents are not free to handle non-conformant
    documents as they please; the processing model described in this specification applies to
    implementations regardless of the conformity of the input documents.
  </p>

  User agents fall into several (overlapping) categories with different conformance requirements.

  : Web browsers and other interactive user agents

  :: Web browsers that support <a>the XHTML syntax</a> must process elements and attributes
      from the <a>HTML namespace</a> found in XML documents as described in this specification,
      so that users can interact with them, unless the semantics of those elements have been
      overridden by other specifications.

      <p class="example">
        A conforming XHTML processor would, upon finding an XHTML <code>script</code>
        element in an XML document, execute the script contained in that element. However, if the
        element is found within a transformation expressed in XSLT (assuming the user agent also
        supports XSLT), then the processor would instead treat the <code>script</code> element as an
        opaque element that forms part of the transform.
      </p>

      Web browsers that support <a>the HTML syntax</a> must process documents labeled with an
      <a>HTML MIME type</a> as described in this specification, so that users can interact with
      them.

      User agents that support scripting must also be conforming implementations of the IDL
      fragments in this specification, as described in the Web IDL specification. [[!WEBIDL]]

      <p class="note">
        Unless explicitly stated, specifications that override the semantics of HTML
        elements do not override the requirements on DOM objects representing those elements. For
        example, the <code>script</code> element in the example above would still implement the
        <code>HTMLScriptElement</code> interface.
      </p>

  : Non-interactive presentation user agents

  :: User agents that process HTML and XHTML documents purely to render non-interactive versions
      of them must comply to the same conformance criteria as Web browsers, except that they are
      exempt from requirements regarding user interaction.

      <p class="note">
        Typical examples of non-interactive presentation user agents are printers
        (static UAs) and overhead displays (dynamic UAs). It is expected that most static
        non-interactive presentation user agents will also opt to <a>lack scripting support</a>.
      </p>

      <p class="example">
        A non-interactive but dynamic presentation UA would still execute scripts,
        allowing forms to be dynamically submitted, and so forth. However, since the concept of "focus"
        is irrelevant when the user cannot interact with the document, the UA would not need to support
        any of the focus-related DOM APIs.
      </p>

  : Visual user agents that support the suggested default rendering

  :: User agents, whether interactive or not, may be designated (possibly as a user option) as
      supporting the suggested default rendering defined by this specification.

      This is not required. In particular, even user agents that do implement the suggested default
      rendering are encouraged to offer settings that override this default to improve the experience
      for the user, e.g. changing the color contrast, using different focus styles, or otherwise
      making the experience more accessible and usable to the user.

      User agents that are designated as supporting the suggested default rendering must, while so
      designated, implement the rules in <a>the rendering section</a> that that
      section defines as the behavior that user agents are <em>expected</em> to implement.

  : User agents with no scripting support

  :: Implementations that do not support scripting (or which have their scripting features
      disabled entirely) are exempt from supporting the events and DOM interfaces mentioned in this
      specification. For the parts of this specification that are defined in terms of an events model
      or in terms of the DOM, such user agents must still act as if events and the DOM were
      supported.

      <p class="note">
        Scripting can form an integral part of an application. Web browsers that do not
        support scripting, or that have scripting disabled, might be unable to fully convey the author's
        intent.
      </p>

  : Conformance checkers

  :: Conformance checkers must verify that a document conforms to the applicable conformance
      criteria described in this specification. Automated conformance checkers are exempt from
      detecting errors that require interpretation of the author's intent (for example, while a
      document is non-conforming if the content of a <code>blockquote</code> element is not a quote,
      conformance checkers running without the input of human judgement do not have to check that
      <code>blockquote</code> elements only contain quoted material).

      Conformance checkers must check that the input document conforms when parsed without a
      <a>browsing context</a> (meaning that no scripts are run, and that the parser's
      <a>scripting flag</a> is disabled), and should also check that the input document conforms
      when parsed with a <a>browsing context</a> in which scripts execute, and that the scripts
      never cause non-conforming states to occur other than transiently during script execution
      itself. (This is only a "SHOULD" and not a "MUST" requirement because it has been proven to be
      impossible. [[!COMPUTABLE]]

      The term "HTML validator" can be used to refer to a conformance checker that itself conforms
      to the applicable requirements of this specification.

      <div class="note">

        XML DTDs cannot express all the conformance requirements of this specification. Therefore, a
        validating XML processor and a DTD cannot constitute a conformance checker. Also, since neither
        of the two authoring formats defined in this specification are applications of SGML, a
        validating SGML system cannot constitute a conformance checker either.

        To put it another way, there are three types of conformance criteria:

        <ol>

        <li>Criteria that can be expressed in a DTD.</li>

        <li>Criteria that cannot be expressed by a DTD, but can still be checked by a machine.</li>

        <li>Criteria that can only be checked by a human.</li>

        </ol>

        A conformance checker must check for the first two. A simple DTD-based validator only checks
        for the first class of errors and is therefore not a conforming conformance checker according
        to this specification.

      </div>



    : Data mining tools

    :: Applications and tools that process HTML and XHTML documents for reasons other than to either
          render the documents or check them for conformance should act in accordance with the semantics
          of the documents that they process.

          <p class="example">
            A tool that generates <a>document outlines</a> but
            increases the nesting level for each paragraph and does not increase the nesting level for each
            section would not be conforming.
          </p>


  : Authoring tools and markup generators

  :: Authoring tools and markup generators must generate <a>conforming documents</a>.
      Conformance criteria that apply to authors also apply to authoring tools, where appropriate.

      Authoring tools are exempt from the strict requirements of using elements only for their
      specified purpose, but only to the extent that authoring tools are not yet able to determine
      author intent. However, authoring tools must not automatically misuse elements or encourage
      their users to do so.

      <p class="example">
        For example, it is not conforming to use an <code>address</code> element for arbitrary
        contact information; that element can only be used for marking up contact information for
        the author of the document or section. However, since an authoring tool is likely unable
        to determine the difference, an authoring tool is exempt from that requirement. This does
        not mean, though, that authoring tools can use <code>address</code> elements for any block
        of italics text (for instance); it just means that the authoring tool doesn't have to
        verify that when the user uses a tool for inserting contact information for a section,
        that the user really is doing that and not inserting something else instead.
      </p>

      <p class="note">
        In terms of conformance checking, an editor has to output documents that conform to the
        same extent that a conformance checker will verify.
      </p>

      When an authoring tool is used to edit a non-conforming document, it may preserve the
      conformance errors in sections of the document that were not edited during the editing
      session (i.e. an editing tool is allowed to round-trip erroneous content). However, an
      authoring tool must not claim that the output is conformant if errors have been so
      preserved.

      Authoring tools are expected to come in two broad varieties: tools that work from structure
      or semantic data, and tools that work on a What-You-See-Is-What-You-Get media-specific
      editing basis (WYSIWYG).

      The former is the preferred mechanism for tools that author HTML, since the structure in the
      source information can be used to make informed choices regarding which HTML elements and
      attributes are most appropriate.

      However, WYSIWYG tools are legitimate. WYSIWYG tools should use elements they know are
      appropriate, and should not use elements that they do not know to be appropriate. This might
      in certain extreme cases mean limiting the use of flow elements to just a few elements, like
      <code>div</code>, <code>b</code>, <code>i</code>, and <code>span</code> and making liberal
      use of the <code>style</code> attribute.

      All authoring tools, whether WYSIWYG or not, should make a best effort attempt at enabling
      users to create well-structured, semantically rich, media-independent content.


  User agents may impose implementation-specific limits on otherwise unconstrained inputs,
  e.g. to prevent denial of service attacks, to guard against running out of memory, or to work
  around platform-specific limitations.

  <a class="fingerprint" href="#fingerprinting-vector"><img height="21" src="images/fingerprint.png" width="15" alt="(This is a fingerprinting vector.)" /></a>

  For compatibility with existing content and prior specifications, this specification describes
  two authoring formats: one based on XML (referred to as <a>the XHTML syntax</a>), and one
  using a <a>custom format</a> inspired by SGML (referred to as <a>the HTML
  syntax</a>). Implementations must support at least one of these two formats, although
  supporting both is encouraged.

  Some conformance requirements are phrased as requirements on elements, attributes, methods or
  objects. Such requirements fall into two categories: those describing content model restrictions,
  and those describing implementation behavior. Those in the former category are requirements on
  documents and authoring tools. Those in the second category are requirements on user agents.
  Similarly, some conformance requirements are phrased as requirements on authors; such requirements
  are to be interpreted as conformance requirements on the documents that authors produce. (In other
  words, this specification does not distinguish between conformance criteria on authors and
  conformance criteria on documents.)

  </div>


  <div class="impl">

<h4 id="dependencies">Dependencies</h4>

  This specification relies on several other underlying specifications.

  <dl>

  : Unicode and Encoding

  :: The Unicode character set is used to represent textual data, and the Encoding standard
      defines requirements around <a>character encodings</a>. [[!UNICODE]]

      <p class="note">
        This specification <a href="#encoding-terminology">introduces terminology</a>
        based on the terms defined in those specifications, as described earlier.
      </p>

      The following terms are used as defined in the Encoding standard: [[!ENCODING]]

      * <dfn>Getting an encoding</dfn>

      * The <dfn>encoder</dfn> and <dfn>decoder</dfn> algorithms for various encodings, including
        the <dfn>UTF-8 encoder</dfn> and <dfn>UTF-8 decoder</dfn>

      * The generic <dfn>decode</dfn> algorithm which takes a byte stream and an encoding and
        returns a character stream

      * The <dfn>UTF-8 decode</dfn> algorithm which takes a byte stream and returns a character
        stream, additionally stripping one leading UTF-8 Byte Order Mark (BOM), if any

      <p class="note">
        The <a>UTF-8 decoder</a> is distinct from the <i>UTF-8 decode algorithm</i>. The latter
        first strips a Byte Order Mark (BOM), if any, and then invokes the former.
      </p>

      For readability, character encodings are sometimes referenced in this specification with a
      case that differs from the canonical case given in the Encoding standard. (For example,
      "UTF-16LE" instead of "utf-16le".)



  : XML and related specifications

  :: Implementations that support <span>the XHTML syntax</span> must support some version of XML,
      as well as its corresponding namespaces specification, because that syntax uses an XML
      serialization with namespaces. <a href="#refsXML">\[XML]</a> <a href="#refsXMLNS">\[XMLNS]</a>

      The attribute with the tag name <dfn><code
      data-x="attr-xml-space">xml:space</code></dfn> in the <span>XML namespace</span> is defined by
      the XML specification. <a href="#refsXML">\[XML]</a>

      This specification also references the <dfn
      data-x-href="http://www.w3.org/TR/xml-stylesheet/#the-xml-stylesheet-processing-instruction"><code>&lt;?xml-stylesheet?></code></dfn>
      processing instruction, defined in the <cite>Associating Style Sheets with XML documents</cite>
      specification. <a href="#refsXMLSSPI">\[XMLSSPI]</a>

      This specification also non-normatively mentions the <dfn><code>XSLTProcessor</code>
      </dfn> interface and its <dfn><code>transformToFragment()</code></dfn> and
      <dfn><code>transformToDocument()</code></dfn> methods.


  : URLs

  :: The following terms are defined in the WHATWG URL standard: <a href="#refsURL">\[URL]</a>

      * <dfn>domain</dfn>
      * <dfn>URL</dfn>
      * <dfn>Origin</dfn> of URLs
      * <dfn>Absolute URL</dfn>
      * <dfn>Relative URL</dfn>
      * <dfn>Relative schemes</dfn>
      * The <dfn>URL parser</dfn> and <dfn>basic URL parser</dfn> as well as these parser states:
        * <dfn>scheme start state</dfn>
        * <dfn>host state</dfn>
        * <dfn>hostname state</dfn>
        * <dfn>port state</dfn>
        * <dfn>path start state</dfn>
        * <dfn>query state</dfn>
        * <dfn>fragment state</dfn>

      * <dfn>Parsed URL</dfn>
      * The <dfn>scheme</dfn> component of a <a>parsed URL</a>
      * The <dfn>scheme data</dfn> component of a <a>parsed URL</a>
      * The <dfn>username</dfn> component of a <a>parsed URL</a>
      * The <dfn>password</dfn> component of a <a>parsed URL</a>
      * The <dfn>host</dfn> component of a <a>parsed URL</a>
      * The <dfn>port</dfn> component of a <a>parsed URL</a>
      * The <dfn>path</dfn> component of a <a>parsed URL</a>
      * The <dfn>query</dfn> component of a <a>parsed URL</a>
      * The <dfn>fragment</dfn> component of a <a>parsed URL</a>
      * <dfn>non-relative flag</dfn>
      * <dfn>Parse errors</dfn> from the <span>URL parser</span>
      * The <dfn>URL serializer</dfn>
      * The <dfn>host serializer</dfn>
      * The <dfn>serialize an integer</dfn>
      * <dfn>Default encode set</dfn>
      * <dfn>Percent encode</dfn>
      * <dfn>UTF-8 percent encode</dfn>
      * <dfn>Percent decode</dfn>
      * <dfn>Decoder error</dfn>
      * <dfn>set the username</dfn>
      * <dfn>set the password</dfn>
      * The <dfn>domain to ASCII</dfn> algorithm
      * The <dfn>domain to Unicode</dfn> algorithm


      A number of schemes and protocols are referenced by this specification also:

      * The <dfn><code>about:</code></dfn> scheme [[!ABOUT]]
      * The <dfn><code>blob:</code></dfn> scheme [[!FILEAPI]]
      * The <dfn><code>data:</code></dfn> scheme [[!RFC2397]]
      * The <dfn><code>http:</code></dfn> scheme [[!HTTP]]
      * The <dfn><code>https:</code></dfn> scheme [[!HTTP]]
      * The <dfn><code>mailto:</code></dfn> scheme [[!MAILTO]]
      * The <dfn><code>sms:</code></dfn> scheme [[!SMS]]
      * The <dfn><code>urn:</code></dfn> scheme [[!URN]]


  : HTTP and related specifications
  :: The following terms are defined in the HTTP specifications: [[!HTTP]]

      * <dfn><code>Accept</code></dfn> header
      * <dfn><code>Accept-Language</code></dfn> header
      * <dfn><code>Cache-Control</code></dfn> header
      * <dfn><code>Content-Disposition</code></dfn> header
      * <dfn><code>Content-Language</code></dfn> header
      * <dfn><code>Content-Length</code></dfn> header
      * <dfn><code>Host</code></dfn> header
      * <dfn><code>Last-Modified</code></dfn> header
      * <dfn><code>Referer</code></dfn> header

      The following terms are defined in the Cookie specification: [[!COOKIES]]


      * <dfn>cookie-string</dfn>
      * <dfn>receives a set-cookie-string</dfn>
      * <dfn><code>Cookie</code></dfn> header


      The following term is defined in the Web Linking specification: [[!WEBLINK]]


      * <dfn><code>Link</code></dfn> header

  : Fetch

  :: The following terms are defined in the WHATWG Fetch specification: [[!FETCH]]

      * <dfn><code>about:blank</code></dfn>
      * <dfn>fetch</dfn>
      * <dfn>ok status</dfn>
      * <dfn><code>Origin</code></dfn> header
      * <dfn>set</dfn>
      * <dfn>response</dfn> and its associated:
        * <dfn>type</dfn>
        * <dfn>url</dfn>
        * <dfn>url list</dfn>
        * <dfn>status</dfn>
        * <dfn>header list</dfn>
        * <dfn>body</dfn>
        * <dfn>internal response</dfn>
        * <dfn>HTTPS state</dfn>
      * <dfn>request</dfn> and its associated:
        * <dfn>url</dfn>
        * <dfn>method</dfn>
        * <dfn>header list</dfn>
        * <dfn>body</dfn>
        * <dfn>client</dfn>
        * <dfn>target browsing context</dfn>
        * <dfn>initiator</dfn>
        * <dfn>type</dfn>
        * <dfn>destination</dfn>
        * <dfn>origin</dfn>
        * <dfn>omit-<code>Origin</code>-header flag</dfn>
        * <dfn>referrer</dfn>
        * <dfn>synchronous flag</dfn>
        * <dfn>mode</dfn>
        * <dfn>credentials mode</dfn>
        * <dfn>use-URL-credentials flag</dfn>
        * <dfn>cache mode</dfn>
        * <dfn>redirect mode</dfn>


<!--TOPIC:DOM APIs-->

  : Web IDL

  :: The IDL fragments in this specification must be interpreted as required for conforming IDL
      fragments, as described in the Web IDL specification. [[!WEBIDL]]

      The following terms are defined in the Web IDL specification:


      * <dfn>Supported property indices</dfn>
      * <dfn>Determine the value of an indexed property</dfn>
      * <dfn>Support named properties</dfn>
      * <dfn>Supported property names</dfn>
      * <dfn>Unenumerable</dfn>
      * <dfn>Determine the value of a named property</dfn>
      * <dfn>Platform array objects</dfn>
      * <dfn>Read only</dfn> (when applied to arrays)
      * <dfn>Callback this value</dfn>
      * <dfn>Converting</dfn> between WebIDL types and JS types
      * <dfn>invoke the Web IDL callback function</dfn>


      The Web IDL specification also defines the following types that are used in Web IDL fragments
      in this specification:



      * <dfn><code>Array</code></dfn>
      * <dfn><code>boolean</code></dfn>
      * <dfn><code>Boolean</code></dfn>
      * <dfn><code>DOMString</code></dfn>
      * <dfn><code>USVString</code></dfn>
      * <dfn><code>double</code></dfn>
      * <dfn><code>Error</code></dfn>
      * <dfn><code>Function</code></dfn>
      * <dfn><code>long</code></dfn>
      * <dfn><code>Map</code></dfn>
      * <dfn><code>Number</code></dfn>
      * <dfn><code>Object</code></dfn>
      * <dfn><code>RegExp</code></dfn>
      * <dfn><code>Set</code></dfn>
      * <dfn><code>String</code></dfn>
      * <dfn><code>unrestricted double</code></dfn>
      * <dfn><code>unsigned long</code></dfn>

      The term <dfn>throw</dfn> in this specification is used as defined in the
      WebIDL specification. The following exception names are defined by WebIDL and used by this
      specification:

      <ol class="brief">
        <li value="1"><dfn><code>IndexSizeError</code></dfn></li>
        <li value="3"><dfn><code>HierarchyRequestError</code></dfn></li>
        <li value="5"><dfn><code>InvalidCharacterError</code></dfn></li>
        <li value="8"><dfn><code>NotFoundError</code></dfn></li>
        <li value="9"><dfn><code>NotSupportedError</code></dfn></li>
        <li value="11"><dfn><code>InvalidStateError</code></dfn></li>
        <li value="12"><dfn><code>SyntaxError</code></dfn></li>
        <li value="15"><dfn><code>InvalidAccessError</code></dfn></li>
        <li value="18"><dfn><code>SecurityError</code></dfn></li>
        <li value="19"><dfn><code>NetworkError</code></dfn></li>
        <li value="22"><dfn><code>QuotaExceededError</code></dfn></li>
        <li value="23"><dfn><code>TimeoutError</code></dfn></li>
        <li value="25"><dfn><code>DataCloneError</code></dfn></li>
        <li><dfn><code>TypeError</code></dfn></li>
      </ol>

      When this specification requires a user agent to
      <dfn>create a <code>Date</code> object</dfn> representing a particular time (which could be
      the special value Not-a-Number), the milliseconds component of that time, if any, must be
      truncated to an integer, and the time value of the newly created
      <code data-x="es-Date">Date</code> object must represent the resulting truncated time.

      <p class="example">
        For instance, given the time 23045 millionths of a second after 01:00 UTC on
        January 1st 2000, i.e. the time 2000-01-01T00:00:00.023045Z, then the
        <code>Date</code> object created representing that time would represent the same
        time as that created representing the time 2000-01-01T00:00:00.023Z, 45 millionths
        earlier. If the given time is NaN, then the result is a <code>Date</code> object that
        represents a time value NaN (indicating that the object does not represent a specific
        instant of time).
      </p>


  : JavaScript

  :: Some parts of the language described by this specification only support JavaScript as the
      underlying scripting language. <a href="#refsECMA262">\[ECMA262]</a>

      <p class="note">
        The term "JavaScript" is used to refer to ECMA262, rather than the official term
        ECMAScript, since the term JavaScript is more widely known. Similarly, the
        <a>MIME type</a> used to refer to JavaScript in this specification is
        <code>text/javascript</code>, since that is the most commonly used type,
        <a>despite it being an officially obsoleted type</a> according to RFC 4329. [[!RFC4329]]
      </p>

      The term <dfn>JavaScript global environment</dfn> refers to the <i>global
      environment</i> concept defined in the ECMAScript specification.

      The ECMAScript <dfn><code data-x="js-SyntaxError">SyntaxError</code></dfn>
      exception is also defined in the ECMAScript specification. <a href="#refsECMA262">\[ECMA262]</a>

      The <dfn>ArrayBuffer</dfn> and related object types and underlying concepts
      from the ECMAScript Specification are used for several features in this specification.
      [[!ECMA262]]

      The <dfn><code data-x="es-Date">Date</code></dfn> object type from the ECMAScript
      Specification is used for several features of this specification. [[!ECMA262]]

      The following helper IDL is used for referring to <code>ArrayBuffer</code>-related types:

      <pre class="idl">typedef (<dfn>Int8Array</dfn> or <dfn>Uint8Array</dfn>
      <dfn>Uint8ClampedArray</dfn> or <dfn>Int16Array</dfn> or <dfn>Uint16Array</dfn> or
      <dfn>Int32Array</dfn> or <dfn>Uint32Array</dfn> or <dfn>Float32Array</dfn> or
      <dfn>Float64Array</dfn> or <dfn>DataView</dfn>) <dfn>ArrayBufferView</dfn>;</pre>

  <p class="note">
    In particular, the <code>Uint8ClampedArray</code> type is used by some <a>2D canvas APIs</a>,
    and the <a><code>WebSocket</code> API</a> uses <code>ArrayBuffer</code> objects for handling
    binary frames.
  </p>


<hr />
<hr />
<hr />


